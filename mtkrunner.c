#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>

#include "mtk_pl.h"

/*----------------------------------------------------------------------------*/

#define MTK_LK_IMG_MAGIC	0x58881688

struct mtk_lk_image {
	uint32_t magic;		/* 0x58881688 */
	uint32_t size;
	char name[32];
	uint32_t addr;
	uint32_t mode;

	uint8_t pad[0x200 - 48];
};

int parseish_lk_img(FILE *fp, size_t fsize, uint32_t *addr, uint32_t *size) {
	struct mtk_lk_image img;

	if (fread(&img, sizeof img, 1, fp) < 1) {
		printf("Couldn't read LK image header (%ld bytes)\n",
			sizeof img);
		return -1;
	}

	if (img.magic != MTK_LK_IMG_MAGIC) {
		printf("Wrong LK image magic: %08x\n", img.magic);
		return -1;
	}

	if (img.addr == 0xffffffff) {
		puts("Image address is undefined!");
		return -1;
	}

	if (img.size > (fsize - sizeof img)) {
		printf("Image claims to be larger than the file: %d > %ld\n",
			img.size, fsize - sizeof img);
		return -1;
	}

	printf("Image name: [%.32s]\n", img.name);

	*addr = img.addr;
	*size = img.size;

	return 0;
}


struct payload_file {
	FILE *fp;
	uint32_t addr;
	size_t size;
	size_t data_off;
};

int payload_open(struct payload_file *pf, char *path, uint32_t addr) {
	if (!pf) return -1;

	FILE *fp = fopen(path, "rb");
	if (!fp) {
		printf("Could not open payload file [%s]\n", path);
		goto Failed;
	}

	fseek(fp, 0, SEEK_END);
	size_t size = ftell(fp);
	fseek(fp, 0, SEEK_SET);

	if (addr == MTK_LK_IMG_MAGIC) {
		uint32_t lkaddr, lksize;

		if (parseish_lk_img(fp, size, &lkaddr, &lksize)) {
			puts("Failed to parse LK image");
			goto FailedClose;
		}

		pf->addr = lkaddr;
		pf->size = lksize;
	} else {
		pf->addr = addr;
		pf->size = size;
	}

	pf->data_off = ftell(fp);
	pf->fp = fp;
	return 0;

FailedClose:
	fclose(fp);
Failed:
	pf->fp = NULL;
	return -1;
}

void payload_close(struct payload_file *pf) {
	if (!pf || !pf->fp) return;

	fclose(pf->fp);
	pf->fp = NULL;
}

int payload_read(struct payload_file *pf, void *ptr, int len) {
	if (!pf || !pf->fp) return -1;

	return fread(ptr, 1, len, pf->fp);
}

/*----------------------------------------------------------------------------*/

int upload_pl_payload(char *path, uint32_t addr) {
	uint16_t tmp16;
	int rc = -1, ret;

	struct payload_file pload;

	if (payload_open(&pload, path, addr))
		goto Exit;

	uint32_t size = pload.size;
	addr = pload.addr;

	printf("Address: 0x%x, Size: %d\n", addr, size);

	if ((ret = mtk_pl_send_da(addr, size, 0))) {
		printf("Failed to send DA (initial part): %x\n", ret);
		goto ExitCloseFile;
	}

	puts("");

	uint16_t check = 0, rcheck;

	for (unsigned n = 0;;) {
		uint8_t block[4096];

		int rdn = payload_read(&pload, block, sizeof(block));
		if (rdn <= 0) break;

		for (int i = 0; i < rdn; ) {
			if ((rdn - i) >= 2) {
				check ^= *(uint16_t*)&block[i];
				i += 2;
			} else {
				check ^= *(uint8_t*)&block[i];
				i += 1;
			}
		}

		struct timespec tss, tse;
		clock_gettime(CLOCK_MONOTONIC, &tss);

		if (mtk_dev_send(block, rdn)) {
			printf("failed");
			break;
		}

		clock_gettime(CLOCK_MONOTONIC, &tse);

		double rtime = (tse.tv_sec + 1e-9 * tse.tv_nsec) - (tss.tv_sec + 1e-9 * tss.tv_nsec);

		n += rdn;

		printf("\e[1A\e[2K[0x%x] %d/%d - %d%% (%.1f kB/s)\n",
			addr + n - rdn, n, size, n * 100 / size, rdn / rtime / 1000.);
	}

	if (mtk_pl_recv16(&rcheck))
		goto ExitCloseFile;
	if (mtk_pl_recv16(&tmp16))
		goto ExitCloseFile;

	if (tmp16) {
		printf("Failed to send DA (final part): %x\n", tmp16);
		goto ExitCloseFile;
	}

	if (check != rcheck) {
		printf("!!! Checksum mismatch - (calc)%04x != (recv)%04x\n", check, rcheck);
		goto ExitCloseFile;
	}

	if ((ret = mtk_pl_jump_da(addr))) {
		printf("Failed to jump into DA (or whatever): %x\n", ret);
		goto ExitCloseFile;
	}

	rc = 0;

ExitCloseFile:
	payload_close(&pload);
Exit:
	return rc;
}

/*===========================================================================*/

/*
 * TODO: these should be removed
 */

#if 0
/* EMI data for homtom ht16 (elpida lpddr3) */
const uint8_t emi_data_mt6580[] = {
	/* No.1 (512 MiB x 2) */
	0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x52,0x50,0x02,0x00,0x00,0xAA,0x00,0xAA,
	0x00,0xAA,0x00,0xAA,0x93,0x44,0x58,0x44,0x00,0x00,0x00,0x01,0x83,0x86,0x04,0xF0,
	0xD1,0x31,0x06,0xA0,0x01,0x04,0x08,0xBF,0x3F,0x6C,0x80,0x01,0x42,0x23,0x64,0xD1,
	0x88,0x88,0x00,0x00,0x88,0x88,0x88,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x10,0x05,0x00,0x11,0x00,0x00,0x80,0x07,0x00,0x26,0x00,0x04,0x00,0x00,0x00,0x20,
	0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0x00,0xC3,0x00,0x02,0x00,0x06,0x00,0x03,0x00,0x02,0x00,
	0x03,0x00,0x00,0x00,0x0A,0x00,0xFF,0x00,0x3F,0x00,0x00,0x00,
	
	/* No.2 (256 MiB x 1) */
	0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2E,0x21,0x00,0x00,0x00,0xAA,0x00,0xAA,
	0x00,0xAA,0x00,0xAA,0x93,0x44,0x58,0x44,0x00,0x00,0x00,0x01,0x83,0x86,0x04,0xF0,
	0xF1,0x32,0x06,0xA0,0x01,0x04,0x08,0xBF,0x3F,0x63,0x40,0x03,0x42,0x23,0x64,0x51,
	0x88,0x88,0x00,0x00,0xEE,0xEE,0xEE,0xEE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x10,0x05,0x00,0x11,0x00,0x00,0x80,0x07,0x00,0x26,0x00,0x04,0x00,0x00,0x00,0x10,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0x00,0xC3,0x00,0x02,0x00,0x06,0x00,0x03,0x00,0x02,0x00,
	0x06,0x00,0x00,0x00,0x0A,0x00,0xFF,0x00,0x3F,0x00,0x00,0x00,
};
#endif

/* There are 7 eMCPs, from preloader_cactus.bin */
const uint8_t emi_data_mt6765[] = {
	0x4D,0x54,0x4B,0x5F,0x42,0x4C,0x4F,0x41,0x44,0x45,0x52,0x5F,
	0x49,0x4E,0x46,0x4F,0x5F,0x76,0x33,0x35,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x70,0x72,0x65,0x6C,0x6F,0x61,0x64,0x65,0x72,
	0x5F,0x63,0x61,0x63,0x74,0x75,0x73,0x2E,0x62,0x69,0x6E,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,

	0x56,0x31,0x31,0x36,0x22,0x88,0x44,0x33,0x90,0x00,0x70,0x00,
	0x4D,0x54,0x4B,0x5F,0x42,0x49,0x4E,0x00,

	/* 7 descriptions */
	0x07,0x00,0x00,0x00,

	/* 0x0100 QE63MB */
	0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x15,0x01,0x00,0x51,0x45,0x36,0x33,0x4D,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x56,0xA0,0x53,0xA0,0x03,0x00,0x44,0x44,
	0xA5,0x03,0x00,0x06,0x01,0x14,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x10,0x42,0x00,0x53,0xA0,0x44,0x00,0x53,0xA0,0x44,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/* 0x014A HAG4a2 */
	/*
	 * That's literally what I have.
	 * [    0.411264] mmc0: new high speed MMC card at address 0001
	 * [    0.412752] mmcblk0: mmc0:0001 HAG4a2 14.7 GiB 
	 */
	0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x90,0x01,0x4A,0x48,0x41,0x47,0x34,0x61,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x56,0xA0,0x53,0xA0,0x03,0x00,0x44,0x44,
	0xA5,0x03,0x00,0x06,0x01,0x14,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x21,0x04,0x53,0xA0,0x44,0x00,0x53,0xA0,0x44,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/* 0x014E S0J9A7 */
	0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x13,0x01,0x4E,0x53,0x30,0x4A,0x39,0x41,0x37,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x56,0xA0,0x53,0xA0,0x03,0x00,0x44,0x44,
	0xA5,0x03,0x00,0x06,0x01,0x14,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x10,0x42,0x00,0x53,0xA0,0x44,0x00,0x53,0xA0,0x44,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/* 0x0100 QD63M7 */
	0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x15,0x01,0x00,0x51,0x44,0x36,0x33,0x4D,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x56,0xA0,0x53,0xA0,0x03,0x00,0x44,0x44,
	0xA5,0x03,0x00,0x06,0x01,0x14,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x21,0x04,0x53,0xA0,0x44,0x00,0x53,0xA0,0x44,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/* 0x0100 GD6BMB */
	0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x15,0x01,0x00,0x47,0x44,0x36,0x42,0x4D,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x66,0xA0,0xA3,0xA0,0x03,0x00,0x48,0x48,
	0xA5,0x03,0x00,0x06,0x01,0x14,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x21,0x04,0x63,0xA0,0x48,0x00,0xA3,0xA0,0x48,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/* 0x014E S0J9B7 */
	0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x13,0x01,0x4E,0x53,0x30,0x4A,0x39,0x42,0x37,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x66,0xA0,0x63,0xA0,0x03,0x00,0x48,0x48,
	0xA5,0x03,0x00,0x06,0x01,0x14,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x21,0x04,0x63,0xA0,0x48,0x00,0x63,0xA0,0x48,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/* 0x014A HBG4a2 */
	0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x90,0x01,0x4A,0x48,0x42,0x47,0x34,0x61,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x66,0xA0,0x63,0xA0,0x03,0x00,0x48,0x48,
	0xA5,0x03,0x00,0x06,0x01,0x14,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x21,0x04,0x63,0xA0,0x48,0x00,0x63,0xA0,0x48,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

/*===========================================================================*/
/* Severally cut-down MT6580 download agent (I patched out most of unrelated stuff...) */

#if 0
int upload_dav1_payload(char *path, uint32_t addr) {
	uint8_t tmp8;
	uint16_t tmp16;
	uint32_t tmp32;
	int rc = -1;

	if (mtk_pl_recv32(&tmp32)) {
		puts("didn't receive the status of the DRAM init!");
		goto Exit;
	}

	if (tmp32 != 0) {
		printf("Looks like we DO need to init DRAM... (it sent %x)\n", tmp32);

		/* EMMC somthing (presence?) */
		if (mtk_pl_recv32(&tmp32))
			goto Exit;

		printf("EMMC whatever-->%08x\n", tmp32);

		/* EMMC CID */
		for (int i = 0; i < 4; i++) {
			if (mtk_pl_recv32(&tmp32))
				goto Exit;
			
			printf("     CID [%d]-->%08x\n", i, tmp32);
		}

		/* NAND something (presence?) */
		if (mtk_pl_recv32(&tmp32))
			goto Exit;

		printf("NAND whatever-->%08x\n", tmp32);

		/* Count of NAND ID? */
		if (mtk_pl_recv16(&tmp16))
			goto Exit;

		/* NAND ID */
		for (int i = 0; i < tmp16; i++) {
			uint16_t tmp16x;
			
			if (mtk_pl_recv16(&tmp16x))
				goto Exit;
			
			printf("     ID [%d]-->%04x\n", i, tmp16x);
		}

		/* OK, I got you, let's proceed to the DRAM init !!! */
		if (mtk_pl_send8(0x5a))
			goto Exit;

		puts("======= Init DRAM! =======");
		mtk_pl_send32(21); //EMI Version
		if (mtk_pl_recv8(&tmp8) && tmp8 == 0x5a) {
			puts("didn't receive (correct) dram init begin ack!!");
			goto Exit;
		}

		/* Size of the single EMI setting entry */
		if (mtk_pl_recv32(&tmp32))
			goto Exit;

		printf("Sizeof entry-->%d\n", tmp32);

		/* OK */
		if (mtk_pl_send8(0x5a))
			goto Exit;

		/* EMI setting size */
		if (mtk_pl_send32(sizeof(emi_data_mt6580)))
			goto Exit;

		/* EMI setting data */
		if (mtk_dev_send((void *)emi_data_mt6580, sizeof(emi_data_mt6580)))
			goto Exit;

		/* Checksum */
		if (mtk_pl_recv16(&tmp16))
			goto Exit;

		printf("Checksum-->%04x\n", tmp16);

		/* OK, everyting is correct, let's do it! */
		if (mtk_pl_send8(0x5a))
			goto Exit;

		/* Whatever */
		if (mtk_pl_send32(0))
			goto Exit;

		/* Init status */
		if (mtk_pl_recv32(&tmp32))
			goto Exit;

		if (tmp32 != 0) {
			/*
			 * That's literally what was in the download agent binary, I'm not making that up.
			 * Definitely gives me some JieLi vibes w...
			 */
			printf("Hi Boy, init dram failed!! (it returned %x)\n", tmp32);
			goto Exit;
		}

		/* Something [2125f8] */
		if (mtk_pl_recv8(&tmp8))
			goto Exit;

		printf("Y1-->%02x\n", tmp8);

		/* Something [2125f9] */
		if (mtk_pl_recv8(&tmp8))
			goto Exit;

		printf("Y2-->%02x\n", tmp8);

		/* Size */
		uint64_t tmp64;

		/* --- high */
		if (mtk_pl_recv32(&tmp32))
			goto Exit;
		tmp64 = (uint64_t)tmp32 << 32;

		/* --- low */
		if (mtk_pl_recv32(&tmp32))
			goto Exit;
		tmp64 |= tmp32;

		printf("Size-->%lx (%.2f GiB)\n",
			tmp64, tmp64 / 1048576. / 1024.);
	} else {
		puts("Looks like we don't need to init DRAM!");
	}

	puts("======= Upload! =======");

	struct payload_file pload;

	if (payload_open(&pload, path, addr))
		goto Exit;

	uint32_t size = pload.size;
	addr = pload.addr;

	uint8_t block[4096];

	printf("Address: 0x%x, Size: %d bytes, Block: %ld bytes\n",
		addr, size, sizeof(block));

	mtk_pl_send32(addr);		/* Address */
	mtk_pl_send32(size);		/* Total length */
	mtk_pl_send32(sizeof(block));	/* Block length */

	if (mtk_pl_recv8(&tmp8) || tmp8 != 0x5a) {
		puts("failed to receive the start ack!");
		goto ExitCloseFile;
	}

	puts("");

	for (int n = 0;;) {
		int rdn = payload_read(&pload, block, sizeof(block));
		if (rdn <= 0) break;

		struct timespec tss, tse;
		clock_gettime(CLOCK_MONOTONIC, &tss);

		if (mtk_dev_send(block, rdn) || mtk_pl_recv8(&tmp8) || tmp8 != 0x5a) {
			printf("failed");
			break;
		}

		clock_gettime(CLOCK_MONOTONIC, &tse);

		double rtime = (tse.tv_sec + 1e-9 * tse.tv_nsec) - (tss.tv_sec + 1e-9 * tss.tv_nsec);

		n += rdn;

		printf("\e[1A\e[2K[0x%x] %d/%d - %d%% (%.3f kB/s)\n",
			addr + n - rdn, n, size, n * 100 / size, rdn / rtime / 1000.);
	}

	puts("");

	rc = 0;

ExitCloseFile:
	payload_close(&pload);
Exit:
	return rc;
}
#endif

/*===========================================================================*/

/*
 * Warning: all of that works only on little-endian platforms!
 * (I decided to use proper types instead of manually writing data there)
 */

enum {
	MTK_XFLASH_CMD_BOOT_TO			= 0x10008,
	MTK_XFLASH_CMD_INIT_EXT_RAM		= 0x1000A,
	MTK_XFLASH_CMD_SETUP_ENVIROMENT		= 0x10100,
	MTK_XFLASH_CMD_SETUP_HW_INIT_PARAMS	= 0x10101
};

#define MTK_XFLASH_SYNC			0x434E5953	/* literally 'SYNC' */



int mtk_xflash_sendpkt(void *ptr, int len) {
	int rc = 0;

	uint32_t tmp[3] = { 0xFEEEEEEF, 1, len };

	if ((rc = mtk_dev_send(tmp, sizeof(tmp))))
		goto Exit;

	if (ptr) {
		if ((rc = mtk_dev_send(ptr, len)))
			goto Exit;
	}

Exit:
	return rc;
}

int mtk_xflash_recvpkt(void *ptr, int len) {
	int rc = 0;

	uint32_t tmp[3];

	if ((rc = mtk_dev_recv(tmp, sizeof(tmp))))
		goto Exit;

	if (tmp[0] != 0xFEEEEEEF && tmp[1] != 1) {
		rc = MTK_PL_COMM_ERR;
		goto Exit;
	}

	uint32_t rlen = tmp[2];
	if (rlen != len) { /* TODO */
		rc = MTK_PL_COMM_ERR;
		goto Exit;
	}

	if ((rc = mtk_dev_recv(ptr, len)))
		goto Exit;
	
Exit:
	return rc;
}

int mtk_xflash_send32(uint32_t val) {
	return mtk_xflash_sendpkt(&val, sizeof val);
}

int mtk_xflash_recv32(uint32_t *val) {
	return mtk_xflash_recvpkt(val, sizeof *val);
}

int mtk_xflash_init(void) {
	int rc = -1;
	uint32_t tmp32;

	/*
	 * Send a sync to DA
	 */
	if (mtk_xflash_send32(MTK_XFLASH_SYNC))
		goto Exit;

	/*
	 * Setup environment
	 */
	{
		uint32_t args[5] = {
			0,	/* Log level: 0 = trace, 1 = debug, 2 = info, 3 = warning, 4 = error, 5 = fatal */
			1,	/* Log channel: 0 = none, 1 = UART, 2 = USB, 3 = UART/USB */
			1,	/* System OS: 0 = bad, 1 = good */
			0,
			0,
		};

		if (mtk_xflash_send32(MTK_XFLASH_CMD_SETUP_ENVIROMENT))
			goto Exit;
		if (mtk_xflash_sendpkt(args, sizeof args))
			goto Exit;
		if (mtk_xflash_recv32(&tmp32) || (tmp32 != 0))
			goto Exit;
	}

	/*
	 * Setup HW init params..
	 */
	if (mtk_xflash_send32(MTK_XFLASH_CMD_SETUP_HW_INIT_PARAMS))
		goto Exit;
	if (mtk_xflash_send32(0))
		goto Exit;
	if (mtk_xflash_recv32(&tmp32) || (tmp32 != 0))
		goto Exit;

	/*
	 * Sync from DA
	 */
	if (mtk_xflash_recv32(&tmp32) || (tmp32 != MTK_XFLASH_SYNC))
		goto Exit;

	/*
	 * Initialize the DRAM - that's what we are all there for!
	 */
	if (mtk_xflash_send32(MTK_XFLASH_CMD_INIT_EXT_RAM))
		goto Exit;
	if (mtk_xflash_recv32(&tmp32) || (tmp32 != 0))
		goto Exit;

	if (mtk_xflash_send32(sizeof(emi_data_mt6765)))
		goto Exit;
	if (mtk_xflash_sendpkt((void *)emi_data_mt6765, sizeof(emi_data_mt6765)))
		goto Exit;
	if (mtk_xflash_recv32(&tmp32) || (tmp32 != 0))
		goto Exit;

	rc = 0;
Exit:
	return rc;
}


int upload_da_payload(char *path, uint32_t addr) {
	int rc = -1;

	uint8_t tmp8;
	uint32_t tmp32;

	/* Receive acknowledge from DA */
	if (mtk_pl_recv8(&tmp8)) {
		puts("Failed to receive acknowledge from DA");
		goto Exit;
	}

	if (tmp8 != 0xc0) {
		printf("Invalid acknowledge from DA: %02x\n", tmp8);
		goto Exit;
	}

	/*====================================================================*/

	/* Init the DA... */

	if (mtk_xflash_init()) {
		puts("Failed to init DA!");
		goto Exit;
	}

	/* And finally send the data! */
	struct payload_file pload;

	if (payload_open(&pload, path, addr))
		goto Exit;

	uint32_t size = pload.size;
	addr = pload.addr;

	printf("Address: 0x%x, Size: %d bytes\n",
		addr, size);

	/* send CMD_BOOT_TO */
	if (mtk_xflash_send32(MTK_XFLASH_CMD_BOOT_TO))
		goto ExitCloseFile;
	if (mtk_xflash_recv32(&tmp32) || tmp32 != 0)
		goto Exit;

	/* send data info */ {
		uint64_t tmp[2] = { addr, size };
		mtk_xflash_sendpkt(tmp, sizeof tmp);
	}

	/* Send a packet header with *full* data length in it... */
	if (mtk_xflash_sendpkt(NULL, size))
		goto ExitCloseFile;

	puts("");

	for (unsigned n = 0;;) {
		uint8_t block[8192];
		int rdn = payload_read(&pload, block, sizeof block);
		if (rdn <= 0) break;

		struct timespec tss, tse;
		clock_gettime(CLOCK_MONOTONIC, &tss);

		if (mtk_dev_send(block, rdn)) {
			puts("failed!");
			goto ExitCloseFile;
		}

		clock_gettime(CLOCK_MONOTONIC, &tse);

		double rtime = (tse.tv_sec + 1e-9 * tse.tv_nsec) - (tss.tv_sec + 1e-9 * tss.tv_nsec);

		n += rdn;

		printf("\e[1A\e[2K[0x%x] %d/%d - %d%% (%.3f kB/s)\n",
			addr + n - rdn, n, size, n * 100 / size, rdn / rtime / 1000.);
	}

	rc = 0;
ExitCloseFile:
	payload_close(&pload);
Exit:
	return rc;
}

/*===========================================================================*/

int get_infos(void) {
	uint8_t tmp8;
	uint16_t tmp16;
	uint16_t aphw_code, aphw_subcode, aphw_ver, apsw_ver;
	uint32_t tgt_cfg;
	int rc = -1;

	/* ---------- Get BL Version ---------- */
	if (mtk_pl_send8(MTKPL_CMD_BL_VER))
		goto Exit;
	if (mtk_pl_recv8(&tmp8))
		goto Exit;

	printf("BL version: %d\n", tmp8);

	/* ---------- Get HW code ---------- */
	if (mtk_pl_send8_echo(MTKPL_CMD_HW_CODE))
		goto Exit;
	if (mtk_pl_recv16(&aphw_code))
		goto Exit;
	if (mtk_pl_recv16(&tmp16))
		goto Exit;

	if (tmp16) {
		printf("Failed to get HW code: %x\n", tmp16);
		goto Exit;
	}

	printf("APHW_CODE    == %04x\n", aphw_code);

	/* ---------- Get HW/SW version ---------- */
	if (mtk_pl_send8_echo(MTKPL_CMD_GET_HW_SW_VER))
		goto Exit;
	if (mtk_pl_recv16(&aphw_subcode))
		goto Exit;
	if (mtk_pl_recv16(&aphw_ver))
		goto Exit;
	if (mtk_pl_recv16(&apsw_ver))
		goto Exit;
	if (mtk_pl_recv16(&tmp16))
		goto Exit;

	if (tmp16) {
		printf("Failed to get HW/SW version: %x\n", tmp16);
		goto Exit;
	}

	printf("APHW_SUBCODE == %04x\n", aphw_subcode);
	printf("APHW_VER     == %04x\n", aphw_ver);
	printf("APSW_VER     == %04x\n", apsw_ver);

	/* ---------- Get target config ---------- */
	if (mtk_pl_send8_echo(MTKPL_CMD_GET_TARGET_CONFIG))
		goto Exit;
	if (mtk_pl_recv32(&tgt_cfg))
		goto Exit;
	if (mtk_pl_recv16(&tmp16))
		goto Exit;

	if (tmp16) {
		printf("Failed to get target config: %x\n", tmp16);
		goto Exit;
	}

	printf("Target config: %x\n", tgt_cfg);

	rc = 0;
Exit:
	return rc;
}


int main(int argc, char **argv) {
	if (argc < 2) {
		printf("Usage: %s <mtk tty> [<payload addr> <payload file> [<payload 2 addr> <payload 2 file>]]\n", argv[0]);
		puts(
			"\n"
			" The first payload is loaded with the BootROM/Preloader protocol,\n"
			" If the second payload is specified, then it is loaded using the\n"
			" 'XFlash' Download Agent protocol (with limited set of the dram datas)\n"
		);
		printf(
			"Specifying a magic value 0x%08x in place of address will interpret\n"
			"the passed payload file as an MTK PL/LK image file instead of a binary file,\n"
			"and will read the actual address from it instead\n"
			"\n",
			MTK_LK_IMG_MAGIC
		);
		return 1;
	}

	if (mtk_dev_connect(argv[1])) {
		puts("Failed to connect to a device");
		return 2;
	}

	int rc = 3;

	if (mtk_pl_handshake()) {
		puts("Failed to send handshake");
		goto Exit;
	}

	if (get_infos())
		goto Exit;

	if (argc >= 4) {
		if (upload_pl_payload(argv[3], strtoul(argv[2], NULL, 0))) {
			puts("[!] Could not upload the first payload via BROM/Preloader.");
			goto Exit;
		}
	}

	if (argc >= 6) {
		if (upload_da_payload(argv[5], strtoul(argv[4], NULL, 0))) {
			puts("[!] Could not upload the second payload via Download Agent.");
			goto Exit;
		}
	}

	rc = 0;
Exit:
	mtk_dev_disconnect();
	return rc;
}

