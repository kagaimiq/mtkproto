#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>

#include "mtk_pl.h"

void hexdump(uint8_t *ptr, int len) {
	for (int i = 0; i < len; i += 16) {
		printf("%p: ", ptr + i);

		for (int j = 0; j < 16; j++) {
			if (i+j >= len) {
				printf("-- ");
			} else {
				printf("%02X ", ptr[i+j]);
			}
		}

		printf(" |");

		for (int j = 0; j < 16; j++) {
			if (i+j >= len) {
				putchar(' ');
			} else {
				uint8_t b = ptr[i+j];
				putchar(b<0x20||b>=0x7f?'.':b);
			}
		}

		printf("|\n");
	}
}


int getSomeInfos(void) {
	uint8_t tmp8;
	uint16_t tmp16;
	uint16_t aphw_code, aphw_subcode, aphw_ver, apsw_ver;
	uint32_t tgt_cfg;
	int rc = -1;

	/* ---------- Get BL Version ---------- */
	if (mtk_pl_sendByte(0xfe))
		goto Exit;

	if (mtk_pl_recvByte(&tmp8))
		goto Exit;

	printf("BLVersion=%d\n", tmp8);

	/* ---------- Get HW code ---------- */
	if (mtk_pl_sendByteChk(0xfd))
		goto Exit;

	/* APHW_CODE */
	if (mtk_pl_recvWord(&aphw_code))
		goto Exit;

	/* RC */
	if (mtk_pl_recvWord(&tmp16))
		goto Exit;

	if (tmp16 != 0) { /* Unlikely to happen but why not */
		printf("GetHwCode Fail=%x\n", tmp16);
		goto Exit;
	}

	/* ---------- Get HW/SW version ---------- */
	if (mtk_pl_sendByteChk(0xfc))
		goto Exit;

	/* APHW_SUBCODE */
	if (mtk_pl_recvWord(&aphw_subcode))
		goto Exit;

	/* APHW_VER */
	if (mtk_pl_recvWord(&aphw_ver))
		goto Exit;

	/* APSW_VER */
	if (mtk_pl_recvWord(&apsw_ver))
		goto Exit;

	/* RC */
	if (mtk_pl_recvWord(&tmp16))
		goto Exit;

	if (tmp16 != 0) { /* Unlikely to happen but why not */
		printf("GetHwSwVer Fail=%x\n", tmp16);
		goto Exit;
	}

	printf("APHW_CODE == %04x\n", aphw_code);
	printf("APHW_SUBCODE == %04x\n", aphw_subcode);
	printf("APHW_VER == %04x\n", aphw_ver);
	printf("APSW_VER == %04x\n", apsw_ver);

	/* ---------- Get Target Config ---------- */
	if (mtk_pl_sendByteChk(0xd8))
		goto Exit;

	/* target config */
	if (mtk_pl_recvDWord(&tgt_cfg))
		goto Exit;

	/* RC */
	if (mtk_pl_recvWord(&tmp16))
		goto Exit;

	if (tmp16 != 0) { /* Unlikely to happen but why not */
		printf("GetTgtCfg Fail=%x\n", tmp16);
		goto Exit;
	}

	printf("Target Config --> %x\n", tgt_cfg);
	if (tgt_cfg & 0x00000001) puts(".... Secure Boot Present!!!");
	if (tgt_cfg & 0x00000002) puts(".... Serial Link Auth!!!!!");
	if (tgt_cfg & 0x00000004) puts(".... Download Agent Auth!!!!!");

	if (tgt_cfg & 0x00000006) {
		printf("Oh No! we have the Authes! We need to do the Exploit! for %04x-%04x-%04x-%04x\n",
			aphw_code, aphw_subcode, aphw_ver, apsw_ver);
	}

	rc = 0;
Exit:
	return rc;
}

int Upload1st(char *path, uint32_t addr) {
	FILE *fp;
	uint16_t tmp16;
	int rc = -1;

	if (!(fp = fopen(path, "rb"))) {
		printf("couldn't open file [%s]!\n", path);
		goto Exit;
	}

	fseek(fp, 0, SEEK_END);
	int size = ftell(fp);
	fseek(fp, 0, SEEK_SET);

	printf("Address: 0x%x, Size: %d\n", addr, size);

	/* ------------CMD_SEND_DA------------ */
	if (mtk_pl_sendByteChk(0xd7))
		goto ExitCloseFile;

	/* address */
	if (mtk_pl_sendDWordChk(addr))
		goto ExitCloseFile;

	/* size */
	if (mtk_pl_sendDWordChk(size))
		goto ExitCloseFile;

	/* hash size (no hash) */
	if (mtk_pl_sendDWordChk(0))
		goto ExitCloseFile;

	/* RC */
	if (mtk_pl_recvWord(&tmp16))
		goto ExitCloseFile;

	if (tmp16 != 0x0000) {
		printf("CMD_SEND_DA initial checks failed : %04x\n", tmp16);
		goto ExitCloseFile;
	}

	/* Data */
	puts("");

	uint16_t check = 0;

	for (int n = 0;;) {
		uint8_t tmp[4096];

		int rdn = fread(tmp, 1, sizeof(tmp), fp);
		if (rdn <= 0) break;

		for (int i = 0; i < rdn; ) {
			if ((rdn - i) >= 2) {
				check ^= *(uint16_t*)&tmp[i];
				i += 2;
			} else {
				check ^= *(uint8_t*)&tmp[i];
				i += 1;
			}
		}

		struct timespec tss, tse;
		clock_gettime(CLOCK_MONOTONIC, &tss);

		if (mtk_pl_sendBytes(tmp, rdn)) {
			printf("failed");
			break;
		}

		clock_gettime(CLOCK_MONOTONIC, &tse);

		double rtime = (1. * tse.tv_sec + 1e-9 * tse.tv_nsec) - (1. * tss.tv_sec + 1e-9 * tss.tv_nsec);

		printf("\e[1A\e[2K[0x%x] %d (%.3f kB/s)\n",
			addr+n, rdn, rdn / rtime / 1000.);

		n += rdn;
	}

	/* Checksum */
	if (mtk_pl_recvWord(&tmp16))
		goto ExitCloseFile;

	printf("Data checksum : %04x v.s. %04x\n", tmp16, check);

	/* RC */
	if (mtk_pl_recvWord(&tmp16))
		goto ExitCloseFile;

	if (tmp16 != 0x0000) {
		printf("CMD_SEND_DA data checks failed : %04x\n", tmp16);
		goto ExitCloseFile;
	}

	/* ---------------CMD_JUMP_DA--------------- */
	if (mtk_pl_sendByteChk(0xd5))
		goto ExitCloseFile;

	/* address */
	if (mtk_pl_sendDWordChk(addr))
		goto ExitCloseFile;

	/* RC */
	if (mtk_pl_recvWord(&tmp16))
		goto ExitCloseFile;

	if (tmp16 != 0x0000) {
		printf("CMD_JUMP_DA failed : %04x\n", tmp16);
		goto ExitCloseFile;
	}

	rc = 0;

ExitCloseFile:
	fclose(fp);
Exit:
	return rc;
}


int mtk_da6765_sendBytes(const void *ptr, int len) {
	int rc = 0;

	uint8_t tmp[12] = {
		0xef,0xee,0xee,0xfe,
		0x01,0x00,0x00,0x00,
		len>>0,len>>8,len>>16,len>>24,
	};

	if ((rc = mtk_pl_sendBytes(tmp, sizeof(tmp))))
		goto Exit;

	if ((rc = mtk_pl_sendBytes(ptr, len)))
		goto Exit;

Exit:
	return rc;
}

int mtk_da6765_recvBytes(void *ptr, int len) {
	int rc = 0;

	uint8_t tmp[12];

	if ((rc = mtk_pl_recvBytes(tmp, sizeof(tmp))))
		goto Exit;

	if ((tmp[0] != 0xef) || (tmp[1] != 0xee) || (tmp[2] != 0xee) || (tmp[3] != 0xfe)) {
		rc = MTK_PL_COMM_ERR;
		goto Exit;
	}

	uint32_t rlen = tmp[8] | (tmp[9] << 8) | (tmp[10] << 16) | (tmp[11] << 24);
	if (rlen != len) { /* TODO */
		rc = MTK_PL_COMM_ERR;
		goto Exit;
	}

	if ((rc = mtk_pl_recvBytes(ptr, len)))
		goto Exit;
	
Exit:
	return rc;
}

int mtk_da6765_sendDWord(uint32_t val) {
	uint8_t tmp[4] = {val, val>>8, val>>16, val>>24};
	return mtk_da6765_sendBytes(tmp, 4);
}

int mtk_da6765_recvDWord(uint32_t *val) {
	uint8_t tmp[4];
	int rc = mtk_da6765_recvBytes(tmp, 4);
	if (rc) return rc;

	*val = tmp[3] << 24 | tmp[2] << 16 | tmp[1] << 8 | tmp[0];
	return MTK_PL_OK;
}


int Upload2nd(char *path, uint32_t addr) {
	int rc = -1;

	uint8_t tmp8;
	uint32_t tmp32;

	/* Recv ACK byte */
	if (mtk_pl_recvByte(&tmp8))
		goto Exit;

	if (tmp8 != 0xc0) {
		printf("invalid ack byte %02x!\n", tmp8);
		goto Exit;
	}

	// From Xiaomi CACTUS preloader
	const uint8_t emi_init_datas[1232] = {
		0x4D, 0x54, 0x4B, 0x5F, 0x42, 0x4C, 0x4F, 0x41, 0x44, 0x45, 0x52, 0x5F,
		0x49, 0x4E, 0x46, 0x4F, 0x5F, 0x76, 0x33, 0x35, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x70, 0x72, 0x65, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x72,
		0x5F, 0x63, 0x61, 0x63, 0x74, 0x75, 0x73, 0x2E, 0x62, 0x69, 0x6E, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x56, 0x31, 0x31, 0x36, 0x22, 0x88, 0x44, 0x33,
		0x90, 0x00, 0x70, 0x00, 0x4D, 0x54, 0x4B, 0x5F, 0x42, 0x49, 0x4E, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00,
		0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x01, 0x00, 0x51,
		0x45, 0x36, 0x33, 0x4D, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0xA0, 0x53, 0xA0,
		0x03, 0x00, 0x44, 0x44, 0xA5, 0x03, 0x00, 0x06, 0x01, 0x14, 0x00, 0x00,
		0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x42, 0x00,
		0x53, 0xA0, 0x44, 0x00, 0x53, 0xA0, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x03, 0x02, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x90, 0x01, 0x4A, 0x48, 0x41, 0x47, 0x34, 0x61, 0x32, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x56, 0xA0, 0x53, 0xA0, 0x03, 0x00, 0x44, 0x44, 0xA5, 0x03, 0x00, 0x06,
		0x01, 0x14, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x21, 0x04, 0x53, 0xA0, 0x44, 0x00, 0x53, 0xA0, 0x44, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x13, 0x01, 0x4E, 0x53, 0x30, 0x4A, 0x39, 0x41,
		0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x56, 0xA0, 0x53, 0xA0, 0x03, 0x00, 0x44, 0x44,
		0xA5, 0x03, 0x00, 0x06, 0x01, 0x14, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x54, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x42, 0x00, 0x53, 0xA0, 0x44, 0x00,
		0x53, 0xA0, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00,
		0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x01, 0x00, 0x51,
		0x44, 0x36, 0x33, 0x4D, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0xA0, 0x53, 0xA0,
		0x03, 0x00, 0x44, 0x44, 0xA5, 0x03, 0x00, 0x06, 0x01, 0x14, 0x00, 0x00,
		0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x04,
		0x53, 0xA0, 0x44, 0x00, 0x53, 0xA0, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x03, 0x02, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x15, 0x01, 0x00, 0x47, 0x44, 0x36, 0x42, 0x4D, 0x42, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0xA0, 0xA3, 0xA0, 0x03, 0x00, 0x48, 0x48, 0xA5, 0x03, 0x00, 0x06,
		0x01, 0x14, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x21, 0x04, 0x63, 0xA0, 0x48, 0x00, 0xA3, 0xA0, 0x48, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x13, 0x01, 0x4E, 0x53, 0x30, 0x4A, 0x39, 0x42,
		0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x66, 0xA0, 0x63, 0xA0, 0x03, 0x00, 0x48, 0x48,
		0xA5, 0x03, 0x00, 0x06, 0x01, 0x14, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x54, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x04, 0x63, 0xA0, 0x48, 0x00,
		0x63, 0xA0, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00,
		0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x01, 0x4A, 0x48,
		0x42, 0x47, 0x34, 0x61, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xA0, 0x63, 0xA0,
		0x03, 0x00, 0x48, 0x48, 0xA5, 0x03, 0x00, 0x06, 0x01, 0x14, 0x00, 0x00,
		0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x04,
		0x63, 0xA0, 0x48, 0x00, 0x63, 0xA0, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	uint8_t rxtmp[128];

	/* ==============send sync================= */
	if (mtk_da6765_sendDWord(0x434e5953))
		goto Exit;

	/* ==============init 1=============== */
	if (mtk_da6765_sendDWord(0x10100))
		goto Exit;
	/* log level - trace(0), log channel - uart(1), system os - linux(1) */
	if (mtk_da6765_sendBytes("\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 20))
		goto Exit;
	if (mtk_da6765_recvDWord(&tmp32))
		goto Exit;
	if (tmp32 != 0)
		goto Exit;

	/* ==============init 2=============== */
	if (mtk_da6765_sendDWord(0x10101))
		goto Exit;
	if (mtk_da6765_sendDWord(0))
		goto Exit;
	if (mtk_da6765_recvDWord(&tmp32))
		goto Exit;
	if (tmp32 != 0)
		goto Exit;

	/* ==============da sync=============== */
	if (mtk_da6765_recvDWord(&tmp32))
		goto Exit;
	if (tmp32 != 0x434e5953)
		goto Exit;

	/* ==============init dram=============== */
	if (mtk_da6765_sendDWord(0x1000a))
		goto Exit;
	if (mtk_da6765_recvDWord(&tmp32))
		goto Exit;
	if (tmp32 != 0)
		goto Exit;

	/* emi init data */
	if (mtk_da6765_sendDWord(sizeof(emi_init_datas)))
		goto Exit;
	if (mtk_da6765_sendBytes(emi_init_datas, sizeof(emi_init_datas)))
		goto Exit;
	if (mtk_da6765_recvDWord(&tmp32))
		goto Exit;
	if (tmp32 != 0)
		goto Exit;

	/* ============ send data ============ */
	FILE *fp = fopen(path, "rb");
	if (!fp) goto Exit;

	/* cmd_boot_to */
	if (mtk_da6765_sendDWord(0x10008))
		goto ExitCloseFile;
	if (mtk_da6765_recvDWord(&tmp32))
		goto ExitCloseFile;
	if (tmp32 != 0)
		goto ExitCloseFile;

	fseek(fp, 0, SEEK_END);
	size_t size = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	
	printf("Address: 0x%x, Size: %d bytes\n",
		addr, size);

	/* send data info */ {
		uint8_t tmp[16] = {
			addr>>0,addr>>8,addr>>16,addr>>24,
			0x00,0x00,0x00,0x00,
			size>>0,size>>8,size>>16,size>>24,
			0x00,0x00,0x00,0x00,
		};
		mtk_da6765_sendBytes(tmp, 16);
	}

	/* send data token (need to specify full data size! why?) */ {
		uint8_t tmp[12] = {
			0xef,0xee,0xee,0xfe,
			0x01,0x00,0x00,0x00,
			size>>0,size>>8,size>>16,size>>24,
		};
		mtk_pl_sendBytes(tmp, sizeof(tmp));
	}

	puts("");

	for (int n = 0;;) {
		uint8_t dtmp[8192];
		size_t rdn = fread(dtmp, 1, sizeof(dtmp), fp);
		if (rdn <= 0) break;

		struct timespec tss, tse;
		clock_gettime(CLOCK_MONOTONIC, &tss);

		if (mtk_pl_sendBytes(dtmp, rdn)) {
			printf("failed");
			break;
		}

		clock_gettime(CLOCK_MONOTONIC, &tse);

		double rtime = (1. * tse.tv_sec + 1e-9 * tse.tv_nsec) - (1. * tss.tv_sec + 1e-9 * tss.tv_nsec);

		printf("\e[1A\e[2K[0x%x] %d (%.3f kB/s)\n",
			addr+n, rdn, rdn / rtime / 1000.);

		n += rdn;
	}

	rc = 0;
ExitCloseFile:
	fclose(fp);
Exit:
	return rc;
}


int main(int argc, char **argv) {
	if (argc < 2) {
		printf("Usage: %s <mtk tty> [<payload addr> <payload file> [<payload 2 addr> <payload 2 file>]]\n", argv[0]);
		puts(
			"\n"
			" The first payload is loaded with the BootROM/Preloader protocol,\n"
			" If the second payload is specified, then it is loaded using the\n"
			" MT6765 Download Agent protocol (with limited set of the dram datas)\n"
			"\n"
		);
		return 1;
	}

	int rc;
	if ((rc = mtk_pl_connect(argv[1]))) {
		printf("failed to connect. (%d)\n", rc);
		return 2;
	}

	for (int try = 10; try >= 0; try--) {
		if (try == 0) {
			puts("send token fail...");
			rc = 2;
			goto Exit;
		}

		uint8_t tmp;

		mtk_pl_flush();

		int fail = 0;
		if (mtk_pl_sendByte(0xa0) || mtk_pl_recvByte(&tmp) || (tmp != 0x5f)) fail++;
		if (mtk_pl_sendByte(0x0a) || mtk_pl_recvByte(&tmp) || (tmp != 0xf5)) fail++;
		if (mtk_pl_sendByte(0x50) || mtk_pl_recvByte(&tmp) || (tmp != 0xaf)) fail++;
		if (mtk_pl_sendByte(0x05) || mtk_pl_recvByte(&tmp) || (tmp != 0xfa)) fail++;

		if (fail) {
			mtk_pl_flush();

			/* check for open connection of bootrom */
			if (!mtk_pl_sendByte(0xff) && !mtk_pl_recvByte(&tmp)) {
				if (tmp == 0x05) break;
			}

			/* check for open connection of preloader/bootrom */
			if (!mtk_pl_sendByte(0xfe) && !mtk_pl_recvByte(&tmp)) {
				if (tmp == 0x01 || tmp == 0xfe) break;
			}
		} else {
			break;
		}
	}

	puts("---------- Get some infos! ------------");
	if (getSomeInfos()) {
		printf("**********couldn't get some infos!***********");
		rc = 2;
		goto Exit;
	}

	if (argc >= 4) {
		puts("---------- Payload upload! ------------");
		if (Upload1st(argv[3], strtoul(argv[2], NULL, 0))) {
			puts("**********couldn't upload payload!***********");
			rc = 2;
			goto Exit;
		}
	}

	if (argc >= 6) {
		puts("---------- Second payload upload! ------------");
		if ((rc = Upload2nd(argv[5], strtoul(argv[4], NULL, 0)))) {
			printf("**********couldn't upload second payload!***********");
			rc = 2;
			goto Exit;
		}
	}

Exit:
	mtk_pl_disconnect();
	return rc;
}
